plot(data[,1],data[,3],type="l",col="red",xlab="Day",ylab="Degrees C")
plot(data[,3],type="l",col="red",xlab="Day",ylab="Degrees C")
points(data[,2],col="blue",xlab="Day",ylab="Presence")
plot(data[,3],type="l",col="red",xlab="Day",ylab="Degrees C")
points(data[,2],col="blue",xlab="Day",ylab="Presence")
## Read in real data and plot
data = read.table("Dolphin_Pres.csv", sep = ",")
plot(data[,3],type="l",col="red",xlab="Day",ylab="Degrees C")
points(data[,2],col="blue",xlab="Day",ylab="Presence")
# ## Run JAGS model on real data
#
# # Bundle data
# jags.data = list(n = n, sst=data[,3], dol.obs=data[,2])
#
# # Initial values
# inits <- function() list(alpha=runif(1, -2, 2), beta=runif(1, -3, 3))
#
# # Parameters monitored
# params <- c("alpha","beta","p","obs.p","mean.obs.p")
#
# # MCMC settings
# ni <- 10000
# nt <- 3
# nb <- 2000
# nc <- 3
#
# library(R2jags)
# out <- jags(jags.data, inits, params, model.file = model, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
norm_sst = data[,3] - min(data[,3])
norm_sst = norm_sst/max(norm_sst)
plot(norm_sst,type="l",col="red",xlab="Day",ylab="Degrees C")
points(data[,2],col="blue",xlab="Day",ylab="Presence")
## Read in real data and plot
data = read.table("Dolphin_Pres.csv", sep = ",")
norm_sst = data[,3] - min(data[,3])
norm_sst = norm_sst/max(norm_sst)
plot(norm_sst,type="l",col="red",xlab="Day",ylab="Degrees C")
points(data[,2],col="blue",xlab="Day",ylab="Presence")
# ## Run JAGS model on real data
#
# # Bundle data
# jags.data = list(n = n, sst=data[,3], dol.obs=data[,2])
#
# # Initial values
# inits <- function() list(alpha=runif(1, -2, 2), beta=runif(1, -3, 3))
#
# # Parameters monitored
# params <- c("alpha","beta","p","obs.p","mean.obs.p")
#
# # MCMC settings
# ni <- 10000
# nt <- 3
# nb <- 2000
# nc <- 3
#
# library(R2jags)
# out <- jags(jags.data, inits, params, model.file = model, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
traceplot(test,pars=c("alpha","beta","mean.obs.p"))
traceplot(test,c("alpha","beta","mean.obs.p"))
traceplot(test,col=1:4)
traceplot(test,col=1:4)
library(coda)
View(test)
library(coda)
traceplot(test[["BUGSoutput"]][["sims.list"]][["alpha"]])
detach("package:coda", unload = TRUE)
#library(coda)
traceplot(test[["BUGSoutput"]][["sims.list"]][["alpha"]])
# Bundle data
jags.data = list(n = n, sst=sst, dol.obs=dol.obs)
# Initial values
inits <- function() list(alpha=runif(1, -2, 2), beta=runif(1, -3, 3))
# Parameters monitored
params <- c("alpha","beta","mean.obs.p")
# MCMC settings
ni <- 10000
nt <- 3
nb <- 2000
nc <- 3
library(R2jags)
test <- jags(jags.data, inits, params, model.file = model, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
attach(test)
print(test)
library(coda)
traceplot(test)
View(test)
# Simulate SST and dolphin presence data
n = 365 # simulating daily presence and SST
day = seq(1,n,1)
temp.ts = function(n=n){
t <- seq(0,1,1/(n-1))
a <- 6
f <- 1
c.norm <- rnorm(n,mean=0,sd=1) # random noise
sst <- a*sin(2*pi*f*t)+c.norm # sst is sine wave with a bunch of noise
sst = sst + abs(min(sst)) + 6 # shift sine wave up into range of actual sst values (in Celsius)
return(sst)
}
sst = temp.ts(n=n)
dolphin_pres = function(n=n, sst=sst, alpha=alpha, beta=beta, mean.p=mean.p){
dol.pres = vector()
log.p = vector()
p = vector()
# state process
for (i in 1:n){
log.p[i] = alpha + sst[i]*beta + rnorm(1,mean=0,sd=0.01) # log odds of presence is a function of SST, plus noise
p[i] = exp(log.p[i])/(1+exp(log.p[i]))  # inverse logit to convert from log odds to probability
dol.pres[i] =  rbinom(1,1,p[i]) # presence is a binomial draw
}
# observation process; hidden state is only correctly observed with some time-varying probability
dol.obs = dol.pres
mean.lp <- log(mean.p / (1-mean.p))
obs.p <- plogis(mean.lp + rnorm(n, 0, 1)) # time-varying detection prob as a random effect
obs.TF = vector()
for (i in 1:n){
obs.TF[i] = rbinom(1,1,obs.p[i]) # given actual dolphin presence, are dolphins observed?
if (obs.TF[i] == 1){
dol.obs[i] = dol.obs[i]  # if yes, keep the 1 for presence
} else {
dol.obs[i] = 0     # if not, create false negatives
}
}
return(dol.obs)
}
dol.obs = dolphin_pres(n=n, sst=sst, alpha= 0.01, beta=0.1, mean.p=0.85)
plot(day,sst,xlab="Day",ylab="Degrees C",main="SST")
plot(day,dol.obs,xlab="Day",ylab="Presence",main="Dolphin Presence")
# Simulate SST and dolphin presence data
n = 365 # simulating daily presence and SST
day = seq(1,n,1)
temp.ts = function(n=n){
t <- seq(0,1,1/(n-1))
a <- 6
f <- 1
c.norm <- rnorm(n,mean=0,sd=2) # random noise
sst <- a*sin(2*pi*f*t)+c.norm # sst is sine wave with a bunch of noise
sst = sst + abs(min(sst)) + 6 # shift sine wave up into range of actual sst values (in Celsius)
return(sst)
}
sst = temp.ts(n=n)
dolphin_pres = function(n=n, sst=sst, alpha=alpha, beta=beta, mean.p=mean.p){
dol.pres = vector()
log.p = vector()
p = vector()
# state process
for (i in 1:n){
log.p[i] = alpha + sst[i]*beta + rnorm(1,mean=0,sd=0.01) # log odds of presence is a function of SST, plus noise
p[i] = exp(log.p[i])/(1+exp(log.p[i]))  # inverse logit to convert from log odds to probability
dol.pres[i] =  rbinom(1,1,p[i]) # presence is a binomial draw
}
# observation process; hidden state is only correctly observed with some time-varying probability
dol.obs = dol.pres
mean.lp <- log(mean.p / (1-mean.p))
obs.p <- plogis(mean.lp + rnorm(n, 0, 1)) # time-varying detection prob as a random effect
obs.TF = vector()
for (i in 1:n){
obs.TF[i] = rbinom(1,1,obs.p[i]) # given actual dolphin presence, are dolphins observed?
if (obs.TF[i] == 1){
dol.obs[i] = dol.obs[i]  # if yes, keep the 1 for presence
} else {
dol.obs[i] = 0     # if not, create false negatives
}
}
return(dol.obs)
}
dol.obs = dolphin_pres(n=n, sst=sst, alpha= 0.01, beta=0.1, mean.p=0.85)
plot(day,sst,xlab="Day",ylab="Degrees C",main="SST")
plot(day,dol.obs,xlab="Day",ylab="Presence",main="Dolphin Presence")
## Build JAGS model
model = function(){
# Prior for probability of dolphin presence
alpha ~ dunif(-10, 10)
beta ~ dunif(-10, 10)
# Prior for probability of correct observation
mean.obs.p ~ dunif(0, 1)                        # hyperparameter of distribution of detection probabilities
mean.lobs.p <- logit(mean.obs.p)
tau <- 1 / (sd * sd)
sd ~ dunif(0, 5)
# Likelihood
for (i in 1:n) {
logit.p[i] <- alpha + sst[i]*beta                   # model probability of presence as linear function of SST
p[i] <- exp(logit.p[i])/(1+exp(logit.p[i]))         # inverse logit
dol.pres[i] ~ dbern(p[i])                           # hidden state - are dolphins actually present?
logit.obs.p[i] ~ dnorm(mean.lobs.p, tau)            # obs.p changes over time
obs.p[i] <- exp(logit.obs.p[i])/(1+exp(logit.obs.p[i]))
p.eff[i] <- (dol.pres[i] * obs.p[i]) + 0.0000001    # given presence, what's the prob of detection?
dol.obs[i] ~ dbern(p.eff[i])                        # observed state
} #i
}
# Bundle data
jags.data = list(n = n, sst=sst, dol.obs=dol.obs)
# Initial values
inits <- function() list(alpha=runif(1, -2, 2), beta=runif(1, -3, 3))
# Parameters monitored
params <- c("alpha","beta","mean.obs.p")
# MCMC settings
ni <- 10000
nt <- 3
nb <- 2000
nc <- 3
library(R2jags)
test <- jags(jags.data, inits, params, model.file = model, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
attach(test)
print(test)
## Build JAGS model
model = function(){
# Prior for probability of dolphin presence
alpha ~ dunif(-10, 10)
beta ~ dunif(-10, 10)
# Prior for probability of correct observation
mean.obs.p ~ dunif(0, 1)                        # hyperparameter of distribution of detection probabilities
mean.lobs.p <- logit(mean.obs.p)
tau <- 1 / (sd * sd)
sd ~ dunif(0, 5)
# Likelihood
for (i in 1:n) {
logit.p[i] <- alpha + sst[i]*beta                   # model probability of presence as linear function of SST
p[i] <- exp(logit.p[i])/(1+exp(logit.p[i]))         # inverse logit
dol.pres[i] ~ dbern(p[i])                           # hidden state - are dolphins actually present?
logit.obs.p[i] ~ dnorm(mean.lobs.p, tau)            # obs.p changes over time
obs.p[i] <- exp(logit.obs.p[i])/(1+exp(logit.obs.p[i]))
p.eff[i] <- (dol.pres[i] * obs.p[i]) + 0.0000001    # given presence, what's the prob of detection?
dol.obs[i] ~ dbern(p.eff[i])                        # observed state
} #i
}
# Bundle data
jags.data = list(n = n, sst=sst, dol.obs=dol.obs)
# Initial values
inits <- function() list(alpha=runif(1, -2, 2), beta=runif(1, -3, 3))
# Parameters monitored
params <- c("alpha","beta","mean.obs.p")
# MCMC settings
ni <- 10000
nt <- 3
nb <- 2000
nc <- 3
library(R2jags)
test <- jags(jags.data, inits, params, model.file = model, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
attach(test)
print(test)
rm(test)
sst
## Build JAGS model
model = function(){
# Prior for probability of dolphin presence
alpha ~ dunif(-10, 10)
beta ~ dunif(-10, 10)
# Prior for probability of correct observation
mean.obs.p ~ dunif(0, 1)                        # hyperparameter of distribution of detection probabilities
mean.lobs.p <- logit(mean.obs.p)
tau <- 1 / (sd * sd)
sd ~ dunif(0, 5)
# Likelihood
for (i in 1:n) {
logit.p[i] <- alpha + sst[i]*beta                   # model probability of presence as linear function of SST
p[i] <- exp(logit.p[i])/(1+exp(logit.p[i]))         # inverse logit
dol.pres[i] ~ dbern(p[i])                           # hidden state - are dolphins actually present?
logit.obs.p[i] ~ dnorm(mean.lobs.p, tau)            # obs.p changes over time
obs.p[i] <- exp(logit.obs.p[i])/(1+exp(logit.obs.p[i]))
p.eff[i] <- (dol.pres[i] * obs.p[i]) + 0.0000001    # given presence, what's the prob of detection?
dol.obs[i] ~ dbern(p.eff[i])                        # observed state
} #i
}
# Bundle data
jags.data = list(n = n, sst=sst, dol.obs=dol.obs)
# Initial values
inits <- function() list(alpha=runif(1, -2, 2), beta=runif(1, -3, 3))
# Parameters monitored
params <- c("alpha","beta","mean.obs.p")
# MCMC settings
ni <- 20000
nt <- 4
nb <- 5000
nc <- 3
library(R2jags)
test <- jags(jags.data, inits, params, model.file = model, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
attach(test)
print(test)
11250/3
3750*4
library(coda)
traceplot(test)
## Read in real data and plot
data = read.table("Dolphin_Pres.csv", sep = ",")
norm_sst = data[,3] - min(data[,3])
norm_sst = norm_sst/max(norm_sst)
plot(norm_sst,type="l",col="red",xlab="Day",ylab="Degrees C")
points(data[,2],col="blue",xlab="Day",ylab="Presence")
## Run JAGS model on real data
# Bundle data
jags.data = list(n = n, sst=data[,3], dol.obs=data[,2])
# Initial values
inits <- function() list(alpha=runif(1, -2, 2), beta=runif(1, -3, 3))
# Parameters monitored
params <- c("alpha","beta","mean.obs.p")
# MCMC settings
ni <- 10000
nt <- 3
nb <- 2000
nc <- 3
library(R2jags)
out <- jags(jags.data, inits, params, model.file = model, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
## Run JAGS model on real data
# Bundle data
jags.data = list(n = 363, sst=data[,3], dol.obs=data[,2])
# Initial values
inits <- function() list(alpha=runif(1, -2, 2), beta=runif(1, -3, 3))
# Parameters monitored
params <- c("alpha","beta","mean.obs.p")
# MCMC settings
ni <- 10000
nt <- 3
nb <- 2000
nc <- 3
library(R2jags)
out <- jags(jags.data, inits, params, model.file = model, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
attach(out)
print(out)
traceplot(out)
## Build JAGS model
model = function(){
# Prior for probability of dolphin presence
alpha ~ dunif(-10, 10)
beta ~ dunif(-10, 10)
# Prior for probability of correct observation
mean.obs.p ~ dunif(0, 1)                        # hyperparameter of distribution of detection probabilities
mean.lobs.p <- logit(mean.obs.p)
tau <- 1 / (sd * sd)
sd ~ dunif(0, 5)
# Likelihood
for (i in 1:n) {
logit.p[i] <- alpha + sst[i]*beta                   # model probability of presence as linear function of SST
p[i] <- exp(logit.p[i])/(1+exp(logit.p[i]))         # inverse logit
dol.pres[i] ~ dbern(p[i])                           # hidden state - are dolphins actually present?
logit.obs.p[i] ~ dnorm(mean.lobs.p, tau)            # obs.p changes over time
obs.p[i] <- exp(logit.obs.p[i])/(1+exp(logit.obs.p[i]))
p.eff[i] <- (dol.pres[i] * obs.p[i]) + 0.0000001    # given presence, what's the prob of detection?
dol.obs[i] ~ dbern(p.eff[i])                        # observed state
} #i
}
# Bundle data
jags.data = list(n = n, sst=sst, dol.obs=dol.obs)
# Initial values
inits <- function() list(alpha=runif(1, -2, 2), beta=runif(1, -3, 3))
# Parameters monitored
params <- c("alpha","beta","mean.obs.p")
# MCMC settings
ni <- 200000
nt <- 5
nb <- 50000
nc <- 3
library(R2jags)
test <- jags(jags.data, inits, params, model.file = model, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
attach(test)
print(test)
library(coda)
traceplot(test)
traceplot(test)
# Simulate SST and dolphin presence data
n = 365 # simulating daily presence and SST
day = seq(1,n,1)
temp.ts = function(n=n){
t <- seq(0,1,1/(n-1))
a <- 6
f <- 1
c.norm <- rnorm(n,mean=0,sd=2) # random noise
sst <- a*sin(2*pi*f*t)+c.norm # sst is sine wave with a bunch of noise
sst = sst + abs(min(sst)) + 6 # shift sine wave up into range of actual sst values (in Celsius)
return(sst)
}
sst = temp.ts(n=n)
dolphin_pres = function(n=n, sst=sst, alpha=alpha, beta=beta, mean.p=mean.p){
dol.pres = vector()
log.p = vector()
p = vector()
# state process
for (i in 1:n){
log.p[i] = alpha + sst[i]*beta + rnorm(1,mean=0,sd=0.01) # log odds of presence is a function of SST, plus noise
p[i] = exp(log.p[i])/(1+exp(log.p[i]))  # inverse logit to convert from log odds to probability
dol.pres[i] =  rbinom(1,1,p[i]) # presence is a binomial draw
}
# observation process; hidden state is only correctly observed with some time-varying probability
dol.obs = dol.pres
mean.lp <- log(mean.p / (1-mean.p))
obs.p <- plogis(mean.lp + rnorm(n, 0, 1)) # time-varying detection prob as a random effect
obs.TF = vector()
for (i in 1:n){
obs.TF[i] = rbinom(1,1,obs.p[i]) # given actual dolphin presence, are dolphins observed?
if (obs.TF[i] == 1){
dol.obs[i] = dol.obs[i]  # if yes, keep the 1 for presence
} else {
dol.obs[i] = 0     # if not, create false negatives
}
}
return(dol.obs)
}
dol.obs = dolphin_pres(n=n, sst=sst, alpha= 0.01, beta=0.1, mean.p=0.85)
plot(day,sst,xlab="Day",ylab="Degrees C",main="SST")
plot(day,dol.obs,xlab="Day",ylab="Presence",main="Dolphin Presence")
## Build JAGS model
model = function(){
# Prior for probability of dolphin presence
alpha ~ dunif(-10, 10)
beta ~ dunif(-10, 10)
# Prior for probability of correct observation
mean.obs.p ~ dunif(0, 1)                        # hyperparameter of distribution of detection probabilities
mean.lobs.p <- logit(mean.obs.p)
tau <- 1 / (sd * sd)
sd ~ dunif(0, 5)
# Likelihood
for (i in 1:n) {
logit.p[i] <- alpha + sst[i]*beta                   # model probability of presence as linear function of SST
p[i] <- exp(logit.p[i])/(1+exp(logit.p[i]))         # inverse logit
dol.pres[i] ~ dbern(p[i])                           # hidden state - are dolphins actually present?
logit.obs.p[i] ~ dnorm(mean.lobs.p, tau)            # obs.p changes over time
obs.p[i] <- exp(logit.obs.p[i])/(1+exp(logit.obs.p[i]))
p.eff[i] <- (dol.pres[i] * obs.p[i]) + 0.0000001    # given presence, what's the prob of detection?
dol.obs[i] ~ dbern(p.eff[i])                        # observed state
} #i
}
# Bundle data
jags.data = list(n = n, sst=sst, dol.obs=dol.obs)
# Initial values
inits <- function() list(alpha=runif(1, -2, 2), beta=runif(1, -3, 3))
# Parameters monitored
params <- c("alpha","beta","mean.obs.p")
# MCMC settings
ni <- 200000
nt <- 5
nb <- 50000
nc <- 3
library(R2jags)
test <- jags(jags.data, inits, params, model.file = model, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
attach(test)
print(test)
library(coda)
traceplot(test)
jags.data = list(n = n, sst=sst, dol.obs=dol.obs)
# Initial values
inits <- function() list(alpha=runif(1, -2, 2), beta=runif(1, -3, 3))
# Parameters monitored
params <- c("alpha","beta","mean.obs.p")
# MCMC settings
ni <- 20000
nt <- 3
nb <- 5000
nc <- 3
library(R2jags)
test <- jags(jags.data, inits, params, model.file = model, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
attach(test)
print(test)
library(coda)
traceplot(test)
ni <- 50000
nt <- 5
nb <- 10000
nc <- 3
library(R2jags)
test <- jags(jags.data, inits, params, model.file = model, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
attach(test)
print(test)
library(coda)
traceplot(test)
## Read in real data and plot
data = read.table("Dolphin_Pres.csv", sep = ",")
norm_sst = data[,3] - min(data[,3])
norm_sst = norm_sst/max(norm_sst)
plot(norm_sst,type="l",col="red",xlab="Day",ylab="Degrees C")
points(data[,2],col="blue",xlab="Day",ylab="Presence")
## Run JAGS model on real data
# Bundle data
jags.data = list(n = 363, sst=data[,3], dol.obs=data[,2])
# Initial values
inits <- function() list(alpha=runif(1, -2, 2), beta=runif(1, -3, 3))
# Parameters monitored
params <- c("alpha","beta","mean.obs.p")
# MCMC settings
ni <- 50000
nt <- 5
nb <- 10000
nc <- 3
library(R2jags)
out <- jags(jags.data, inits, params, model.file = model, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
attach(out)
print(out)
traceplot(out)
setwd("~/Documents/GitHub/HabitatModeling")
load("~/Documents/GitHub/HabitatModeling/Blainville_WeeklyRegionalModel.Rdata")
View(optWeekMod)
plot(optWeekMod$fitted.values)
hist(optWeekMod$fitted.values)
zeroInd = which(optWeekMod$fitted.values==0)
load("~/Documents/GitHub/HabitatModeling/Cuvier_WeeklyRegionalModel.Rdata")
zeroInd = which(optWeekMod$fitted.values==0)
hist(optWeekMod$fitted.values)
load("~/Documents/GitHub/HabitatModeling/Gervais_WeeklyRegionalModel.Rdata")
zeroInd = which(optWeekMod$fitted.values==0)
plot(optWeekMod$fitted.values)
min(optWeekMod$fitted.values)
install.packages(c("maps", "viridis"))
HARPs = data.frame(t(data.frame(c(41.06165, -66.35155), # WAT_HZ
c(40.26333,-67.9861),  # WAT_OC
c(39.83295, -69.98194),  # WAT_NC
c(39.19192, -72.22735),  # WAT_BC
c(38.37337, -73.36985),  # WAT_WC
c(37.16452, -74.46585),  # NFC
c(35.30183,-74.8789),  # HAT_A & HAT_B
c(33.66992, -75.9977),   # WAT_GS
c(32.10527, -77.09067),  # WAT_BP
c(30.58295, -77.39002))))  # WAT_BS
colnames(HARPs) = c("lat","lon")
rownames(HARPs) = c("HZ","OC","NC","BC","WC","NFC","HAT","GS","BP","BS")
