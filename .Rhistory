thisSite = which(!is.na(str_match(data$Site,sites[l])))
matchRow = match(data$Date[thisSite],allDates)
fullDatesDF[matchRow,2:dim(data)[2]] = data[thisSite,2:dim(data)[2]]
colnames(fullDatesDF) = colnames(data)
# create grouping variable
weekID = rep(1:length(weekDates),each=7)
weekID = weekID[1:dim(fullDatesDF)[1]]
fullDatesDF$WeekID = weekID
# sum presence in each week
summaryData = fullDatesDF %>%
group_by(WeekID) %>%
summarize(Pres=sum(Pres,na.rm=TRUE))
weeklyDF = as.numeric()
for (l in 1:length(sites)) {
# Create dataframe to hold data (or NAs) for all dates
fullDatesDF = data.frame(matrix(nrow=length(allDates), ncol=dim(data)[2]))
fullDatesDF[,1] = allDates
# sort the observations we have for this site into the full date range
thisSite = which(!is.na(str_match(data$Site,sites[l])))
matchRow = match(data$Date[thisSite],allDates)
fullDatesDF[matchRow,2:dim(data)[2]] = data[thisSite,2:dim(data)[2]]
colnames(fullDatesDF) = colnames(data)
# create grouping variable
weekID = rep(1:length(weekDates),each=7)
weekID = weekID[1:dim(fullDatesDF)[1]]
fullDatesDF$WeekID = weekID
# sum presence in each week
summaryData = fullDatesDF %>%
group_by(WeekID) %>%
summarize(Pres=sum(Pres,na.rm=TRUE))
# normalize by effort
effDF = data.frame(count=rep(1,length(allDates)),weekID=weekID)
effDF$count[which(is.na(fullDatesDF$Pres))] = 0
propEff = effDF %>%
group_by(weekID) %>%
summarize(sum(count))
summaryData$propEff = unlist(propEff[,2])/7
summaryData$Pres = summaryData$Pres*(1/summaryData$propEff)
summaryData$Site = sites[l]
summaryData$WeekDate = weekDates
for (j in 4:(dim(data)[2])){
var = names(data)[j]
# calculate weekly average for this covar
eval(parse(text=paste('thisCovar=fullDatesDF%>%group_by(WeekID)%>%summarize(',var,'=mean(',var,',na.rm=TRUE))',sep="")))
eval(parse(text='summaryData[[var]]=unlist(thisCovar[,2])'))
}
weeklyDF = rbind(weeklyDF,summaryData)
}
# Center and scale all predictors
weeklyDF[,6:19] = scale(weeklyDF[,6:19],center=TRUE,scale=TRUE)
# Remove incomplete observations (NAs in FSLE)
badRows = unique(which(is.na(weeklyDF),arr.ind=TRUE)[,1])
weeklyDF = weeklyDF[-badRows,]
# re-round presence data
weeklyDF$Pres = round(weeklyDF$Pres)
# Check which covars are correlated w presence to determine starting covar list
smoothVarList = c ("CEddyDist0",
"EKE0",
"FSLE0",
"Sal0",
"SSH0",
"Temp0",
"VelAsp0",
"VelMag0")
# check residual autocorrelation of weekly data
sites = unique(weeklyDF$Site)
residAutocorr = matrix(ncol=1,nrow=length(sites))
rownames(residAutocorr) = sites
for (j in 1:length(sites)){
siteInd = which(!is.na(str_match(weeklyDF$Site,sites[j])))
if (sum(which(weeklyDF$Pres[siteInd]>0))>10){
siteData = weeklyDF[siteInd,]
BlockMod = glm(Pres~bs(CEddyDist0)
+ bs(EKE0)
+ bs(FSLE0) # include all terms in smoothVarList above!!
+ bs(Sal0)
+ bs(SSH0)
+ bs(Temp0)
+ bs(VelAsp0)
+ bs(VelMag0),
data=siteData,family=poisson)
acorr = acf(residuals(BlockMod), lag.max = 1000, main=paste(spec,"at",sites[j]))
CI = ggfortify:::confint.acf(acorr)
ACFidx = which(acorr[["acf"]] < CI, arr.ind=TRUE)
residAutocorr[j,1] = ACFidx[1]
}
}
library(mgcv)
for (j in 1:length(sites)){
siteInd = which(!is.na(str_match(weeklyDF$Site,sites[j])))
if (sum(which(weeklyDF$Pres[siteInd]>0))>10){
siteData = weeklyDF[siteInd,]
BlockMod = glm(Pres~bs(CEddyDist0)
+ bs(EKE0)
+ bs(FSLE0) # include all terms in smoothVarList above!!
+ bs(Sal0)
+ bs(SSH0)
+ bs(Temp0)
+ bs(VelAsp0)
+ bs(VelMag0),
data=siteData,family=poisson)
acorr = acf(residuals(BlockMod), lag.max = 1000, main=paste(spec,"at",sites[j]))
CI = ggfortify:::confint.acf(acorr)
ACFidx = which(acorr[["acf"]] < CI, arr.ind=TRUE)
residAutocorr[j,1] = ACFidx[1]
}
}
library(splines)
for (j in 1:length(sites)){
siteInd = which(!is.na(str_match(weeklyDF$Site,sites[j])))
if (sum(which(weeklyDF$Pres[siteInd]>0))>10){
siteData = weeklyDF[siteInd,]
BlockMod = glm(Pres~bs(CEddyDist0)
+ bs(EKE0)
+ bs(FSLE0) # include all terms in smoothVarList above!!
+ bs(Sal0)
+ bs(SSH0)
+ bs(Temp0)
+ bs(VelAsp0)
+ bs(VelMag0),
data=siteData,family=poisson)
acorr = acf(residuals(BlockMod), lag.max = 1000, main=paste(spec,"at",sites[j]))
CI = ggfortify:::confint.acf(acorr)
ACFidx = which(acorr[["acf"]] < CI, arr.ind=TRUE)
residAutocorr[j,1] = ACFidx[1]
}
}
residAutocorr
library(AER)
# test for overdispersion
dispMod = glm(Pres~bs(CEddyDist0)
+ bs(EKE0)
+ bs(FSLE0) # include all terms in smoothVarList above!!
+ bs(Sal0)
+ bs(SSH0)
+ bs(Temp0)
+ bs(VelAsp0)
+ bs(VelMag0),
data=weeklyDF,family=poisson)
dispersiontest(dispMod,alternative='two.sided')
# data are very overdispersed, will use Tweedie family in models
modFam=tw
# run full model
weekMod = gam(Pres ~ s(CEddyDist0,bs="ts")
+ s(EKE0,bs="ts")
+ s(abs_FSLE0,bs="ts")
+ s(Sal0,bs="ts")
+ s(SSH0,bs="ts")
+ s(Temp0,bs="ts")
+ s(VelAsp0,bs="cc",knots=4)
+ s(VelMag0,bs="ts"),
data=weeklyDF,
family=modFam,
method="REML",
select=TRUE,
gamma=1.4,
optimizer='efs',
na.action="na.fail")
# run full model
weekMod = gam(Pres ~ s(CEddyDist0,bs="ts")
+ s(EKE0,bs="ts")
+ s(FSLE0,bs="ts")
+ s(Sal0,bs="ts")
+ s(SSH0,bs="ts")
+ s(Temp0,bs="ts")
+ s(VelAsp0,bs="cc",knots=4)
+ s(VelMag0,bs="ts"),
data=weeklyDF,
family=modFam,
method="REML",
select=TRUE,
gamma=1.4,
optimizer='efs',
na.action="na.fail")
View(weeklyDF)
# run full model
weekMod = gam(Pres ~ s(CEddyDist0,bs="ts")
+ s(EKE0,bs="ts")
+ s(FSLE0,bs="ts")
+ s(Sal0,bs="ts")
+ s(SSH0,bs="ts")
+ s(Temp0,bs="ts")
+ s(VelAsp0,bs="cc",k=4)
+ s(VelMag0,bs="ts"),
data=weeklyDF,
family=modFam,
method="REML",
select=TRUE,
gamma=1.4,
optimizer='efs',
na.action="na.fail")
# check convergence
# fullMod$converged
# TRUE
weekMod$converged
# check concurvity of smooth terms
conCurv = concurvity(weekMod,full=FALSE)
round(conCurv$estimate,digits=4)
weekMod = gam(Pres ~ s(CEddyDist0,bs="ts")
+ s(EKE0,bs="ts")
+ s(FSLE0,bs="ts")
+ s(Sal0,bs="ts")
# + s(SSH0,bs="ts")
+ s(Temp0,bs="ts")
+ s(VelAsp0,bs="cc",k=4)
+ s(VelMag0,bs="ts"),
data=weeklyDF,
family=modFam,
method="REML",
select=TRUE,
gamma=1.4,
optimizer='efs',
na.action="na.fail")
# check convergence
weekMod$converged
conCurv = concurvity(weekMod,full=FALSE)
round(conCurv$estimate,digits=4)
# Dredge all possible models nested within full model
weekModCompTable = dredge(weekMod,
beta="none",
rank='AIC',
evaluate=TRUE,
trace=TRUE)
library(MuMIn)
# Dredge all possible models nested within full model
weekModCompTable = dredge(weekMod,
beta="none",
rank='AIC',
evaluate=TRUE,
trace=TRUE)
View(weekModCompTable)
# Save best models
# optWeekMod = get.models(weekModCompTable,subset=1)
# optWeekMod = optWeekMod[[names(optWeekMod)]]
# save(optWeekMod,weekModCompTable,file=paste(outDir,'/',spec,'/','WeeklyRegionalModel.Rdata',sep=""))
topMods = get.models(weekModCompTable,subset=delta<2) # all best-performing models
plot.gam(topMods[1],all.terms=TRUE,pages=1,scale=0)
plot.gam(topMods[['128']],all.terms=TRUE,pages=1,scale=0)
View(topMods)
weekMod = gam(Pres ~ s(CEddyDist0,bs="ts")
+ s(EKE0,bs="ts")
+ s(FSLE0,bs="ts")
+ s(Sal0,bs="ts")
# + s(SSH0,bs="ts")
+ s(Temp0,bs="ts")
+ s(VelAsp0,bs="cc",k=4)
+ s(VelMag0,bs="ts"),
data=weeklyDF,
family=modFam,
method="REML",
select=TRUE,
gamma=1.8,
optimizer='efs',
na.action="na.fail")
# Dredge all possible models nested within full model
weekModCompTable = dredge(weekMod,
beta="none",
rank='AIC',
evaluate=TRUE,
trace=TRUE)
View(weekModCompTable)
# Save best models
# optWeekMod = get.models(weekModCompTable,subset=1)
# optWeekMod = optWeekMod[[names(optWeekMod)]]
# save(optWeekMod,weekModCompTable,file=paste(outDir,'/',spec,'/','WeeklyRegionalModel.Rdata',sep=""))
topMods = get.models(weekModCompTable,subset=delta<2) # all best-performing models
plot.gam(topMods[['128']],all.terms=TRUE,pages=1,scale=0)
weekMod = gam(Pres ~ s(CEddyDist0,bs="ts")
+ s(EKE0,bs="ts")
+ s(FSLE0,bs="ts")
+ s(Sal0,bs="ts")
# + s(SSH0,bs="ts")
+ s(Temp0,bs="ts")
+ s(VelAsp0,bs="cc",k=4)
+ s(VelMag0,bs="ts"),
data=weeklyDF,
family=modFam,
method="REML",
select=TRUE,
gamma=1.8,
optimizer='nlm',
na.action="na.fail")
weekMod = gam(Pres ~ s(CEddyDist0,bs="ts")
+ s(EKE0,bs="ts")
+ s(FSLE0,bs="ts")
+ s(Sal0,bs="ts")
# + s(SSH0,bs="ts")
+ s(Temp0,bs="ts")
+ s(VelAsp0,bs="cc",k=4)
+ s(VelMag0,bs="ts"),
data=weeklyDF,
family=modFam,
method="REML",
select=TRUE,
gamma=1.8,
optimizer='n1m',
na.action="na.fail")
weekMod = gam(Pres ~ s(CEddyDist0,bs="ts")
+ s(EKE0,bs="ts")
+ s(FSLE0,bs="ts")
+ s(Sal0,bs="ts")
# + s(SSH0,bs="ts")
+ s(Temp0,bs="ts")
+ s(VelAsp0,bs="cc",k=4)
+ s(VelMag0,bs="ts"),
data=weeklyDF,
family=modFam,
method="REML",
select=TRUE,
gamma=1.8,
optimizer='nlm',
na.action="na.fail")
weekMod = gam(Pres ~ s(CEddyDist0,bs="ts")
+ s(EKE0,bs="ts")
+ s(FSLE0,bs="ts")
+ s(Sal0,bs="ts")
# + s(SSH0,bs="ts")
+ s(Temp0,bs="ts")
+ s(VelAsp0,bs="cc",k=4)
+ s(VelMag0,bs="ts"),
data=weeklyDF,
family=modFam,
method="REML",
select=TRUE,
gamma=1.8,
optimizer=c('outer','bfgs'),
na.action="na.fail")
weekMod = gam(Pres ~ s(CEddyDist0,bs="ts")
+ s(EKE0,bs="ts")
+ s(FSLE0,bs="ts")
+ s(Sal0,bs="ts")
# + s(SSH0,bs="ts")
+ s(Temp0,bs="ts")
+ s(VelAsp0,bs="cc",k=4)
+ s(VelMag0,bs="ts"),
data=weeklyDF,
family=modFam,
method="REML",
select=TRUE,
gamma=1.4,
optimizer=c('outer','bfgs'),
na.action="na.fail")
# check convergence
weekMod$converged
conCurv = concurvity(weekMod,full=FALSE)
round(conCurv$estimate,digits=4)
# Dredge all possible models nested within full model
weekModCompTable = dredge(weekMod,
beta="none",
rank='AIC',
evaluate=TRUE,
trace=TRUE)
View(weekModCompTable)
# Save best models
# optWeekMod = get.models(weekModCompTable,subset=1)
# optWeekMod = optWeekMod[[names(optWeekMod)]]
# save(optWeekMod,weekModCompTable,file=paste(outDir,'/',spec,'/','WeeklyRegionalModel.Rdata',sep=""))
topMods = get.models(weekModCompTable,subset=delta<2) # all best-performing models
plot.gam(topMods[['128']],all.terms=TRUE,pages=1,scale=0)
weekMod = gam(Pres ~ s(CEddyDist0,bs="ts")
+ s(EKE0,bs="ts")
+ s(FSLE0,bs="ts")
+ s(Sal0,bs="ts")
# + s(SSH0,bs="ts")
+ s(Temp0,bs="ts")
+ s(VelAsp0,bs="cc",k=4)
+ s(VelMag0,bs="ts"),
data=weeklyDF,
family=modFam,
method="REML",
select=TRUE,
gamma=1.8,
optimizer=c('outer','bfgs'),
na.action="na.fail")
# check convergence
weekMod$converged
conCurv = concurvity(weekMod,full=FALSE)
round(conCurv$estimate,digits=4)
# Dredge all possible models nested within full model
weekModCompTable = dredge(weekMod,
beta="none",
rank='AIC',
evaluate=TRUE,
trace=TRUE)
View(weekModCompTable)
# Save best models
# optWeekMod = get.models(weekModCompTable,subset=1)
# optWeekMod = optWeekMod[[names(optWeekMod)]]
# save(optWeekMod,weekModCompTable,file=paste(outDir,'/',spec,'/','WeeklyRegionalModel.Rdata',sep=""))
topMods = get.models(weekModCompTable,subset=delta<2) # all best-performing models
View(weekModCompTable)
plot.gam(topMods[['128']],all.terms=TRUE,pages=1,scale=0)
# Save best models
# optWeekMod = get.models(weekModCompTable,subset=1)
# optWeekMod = optWeekMod[[names(optWeekMod)]]
# save(optWeekMod,weekModCompTable,file=paste(outDir,'/',spec,'/','WeeklyRegionalModel.Rdata',sep=""))
topMods = get.models(weekModCompTable,subset=delta<2) # all best-performing models
optWeekMod = model.avg(weekModCompTable,subset=delta<2,fit=TRUE) # averaged model
save(optWeekMod,topMods,weekModCompTable,file=paste(spec,'_','WeeklyRegionalModel_Updated.Rdata',sep=""))
# sink(paste(outDir,'/',spec,'/','WeeklyRegionalModelSummary.txt',sep=""))
sink(paste(spec,'_','WeeklyRegionalModelSummary_Updated.txt',sep=""))
for (i in 1:length(names(topMods))){
print(summary(topMods[[names(topMods)[i]]]))}
sink()
summary(topMods[[1]])
summary(topMods[[2]])
# Retrain model with 2/3 of data, then validate by predicting remaining 1/3
trainInd = sample(1:nrow(weeklyDF),floor(nrow(weeklyDF)*.66))
testInd = setdiff(1:nrow(weeklyDF),trainInd)
valModList = list()
for (i in 1:numel(names(topMods))){
valMod = update(topMods[[1]],data=weeklyDF[trainInd,])
valModList[[i]] = valMod
}
library(pracma)
valModList = list()
for (i in 1:numel(names(topMods))){
valMod = update(topMods[[1]],data=weeklyDF[trainInd,])
valModList[[i]] = valMod
}
avgValMod = model.avg(valModList,subset=delta<2,fit=TRUE)
# plot.gam(valMod,all.terms=TRUE,rug=TRUE,pages=1,scale=0,main="Optimal Model")
save(valModList,avgValMod,file=paste(spec,'_','ValidationModel_Updated.Rdata',sep=""))
true = weeklyDF[testInd,"Pres"]$Pres
preds = predict(avgValMod,weeklyDF[testInd,],full=TRUE,type="link",backtransform=TRUE)
plot(true,preds,type="p")
cor(true,preds)
# Retrain model with 2/3 of data, then validate by predicting remaining 1/3
trainInd = sample(1:nrow(weeklyDF),floor(nrow(weeklyDF)*.66))
testInd = setdiff(1:nrow(weeklyDF),trainInd)
true = weeklyDF[testInd,"Pres"]$Pres
preds = predict(avgValMod,weeklyDF[testInd,],full=TRUE,type="link",backtransform=TRUE)
plot(true,preds,type="p")
cor(true,preds)
# Retrain model with 2/3 of data, then validate by predicting remaining 1/3
trainInd = sample(1:nrow(weeklyDF),floor(nrow(weeklyDF)*.66))
testInd = setdiff(1:nrow(weeklyDF),trainInd)
true = weeklyDF[testInd,"Pres"]$Pres
preds = predict(avgValMod,weeklyDF[testInd,],full=TRUE,type="link",backtransform=TRUE)
plot(true,preds,type="p")
cor(true,preds)
# Retrain model with 2/3 of data, then validate by predicting remaining 1/3
trainInd = sample(1:nrow(weeklyDF),floor(nrow(weeklyDF)*.66))
testInd = setdiff(1:nrow(weeklyDF),trainInd)
true = weeklyDF[testInd,"Pres"]$Pres
preds = predict(avgValMod,weeklyDF[testInd,],full=TRUE,type="link",backtransform=TRUE)
plot(true,preds,type="p")
cor(true,preds)
# Retrain model with 2/3 of data, then validate by predicting remaining 1/3
trainInd = sample(1:nrow(weeklyDF),floor(nrow(weeklyDF)*.66))
testInd = setdiff(1:nrow(weeklyDF),trainInd)
true = weeklyDF[testInd,"Pres"]$Pres
preds = predict(avgValMod,weeklyDF[testInd,],full=TRUE,type="link",backtransform=TRUE)
plot(true,preds,type="p")
cor(true,preds)
weekMod = gam(Pres ~ s(CEddyDist0,bs="ts")
+ s(EKE0,bs="ts")
+ s(FSLE0,bs="ts")
+ s(Sal0,bs="ts")
# + s(SSH0,bs="ts")
+ s(Temp0,bs="ts")
+ s(VelAsp0,bs="cc",k=4)
+ s(VelMag0,bs="ts"),
data=weeklyDF,
family=modFam,
method="REML",
select=TRUE,
gamma=1.4,
optimizer=c('outer','bfgs'),
na.action="na.fail")
# check convergence
weekMod$converged
conCurv = concurvity(weekMod,full=FALSE)
round(conCurv$estimate,digits=4)
# Dredge all possible models nested within full model
weekModCompTable = dredge(weekMod,
beta="none",
rank='AIC',
evaluate=TRUE,
trace=TRUE)
# Save best models
# optWeekMod = get.models(weekModCompTable,subset=1)
# optWeekMod = optWeekMod[[names(optWeekMod)]]
# save(optWeekMod,weekModCompTable,file=paste(outDir,'/',spec,'/','WeeklyRegionalModel.Rdata',sep=""))
topMods = get.models(weekModCompTable,subset=delta<2) # all best-performing models
View(weekModCompTable)
optWeekMod = model.avg(weekModCompTable,subset=delta<2,fit=TRUE) # averaged model
save(optWeekMod,topMods,weekModCompTable,file=paste(spec,'_','WeeklyRegionalModel_Updated.Rdata',sep=""))
# sink(paste(outDir,'/',spec,'/','WeeklyRegionalModelSummary.txt',sep=""))
sink(paste(spec,'_','WeeklyRegionalModelSummary_Updated.txt',sep=""))
for (i in 1:length(names(topMods))){
print(summary(topMods[[names(topMods)[i]]]))}
sink()
# Retrain model with 2/3 of data, then validate by predicting remaining 1/3
trainInd = sample(1:nrow(weeklyDF),floor(nrow(weeklyDF)*.66))
testInd = setdiff(1:nrow(weeklyDF),trainInd)
valModList = list()
for (i in 1:numel(names(topMods))){
valMod = update(topMods[[1]],data=weeklyDF[trainInd,])
valModList[[i]] = valMod
}
avgValMod = model.avg(valModList,subset=delta<2,fit=TRUE)
# plot.gam(valMod,all.terms=TRUE,rug=TRUE,pages=1,scale=0,main="Optimal Model")
save(valModList,avgValMod,file=paste(spec,'_','ValidationModel_Updated.Rdata',sep=""))
true = weeklyDF[testInd,"Pres"]$Pres
preds = predict(avgValMod,weeklyDF[testInd,],full=TRUE,type="link",backtransform=TRUE)
plot(true,preds,type="p")
cor(true,preds)
weekMod
summary(weekMod)
View(weekMod)
2^24
